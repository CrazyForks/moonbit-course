# 现代编程思想：接口

大家好，欢迎来到由IDEA研究院基础软件中心为大家带来的现代编程思想公开课。上节课在学习可变数据结构的时候，我们留了个小尾巴。我们提到实现泛型版本的循环队列的时候，需要在构建数组的时候提供默认值。一种方法是使用`Option`对数据进行包裹，以`None`作为默认值。另一种方式则是依赖类型来提供默认值。一种可能的实现如下方代码所示。而之前实现泛型版本的二叉搜索树的时候，我们同样依赖类型来提供比较的方法。如上方代码所示，我们将比较函数作为参数传进来。这样做不能说不行，但是当我们对类型有较为复杂的需求时，参数的传递可能变为十分不便。

更为重要的是，我们注意到一些函数其实是与类型相关联的。例如数据结构的比较、数据结构的默认值，以及如何将特定类型转化为字符串等。这样的可以与类型直接相关联的函数我们称之为方法。接口则是一系列方法的集合。接口定义的关键词为Trait，我们在内部定义一系列的函数。其中，如果参数或返回值类型为实现该接口的函数，则用`Self`进行指代。例如这里的比较函数，比较的是两个该类型的数据，那么我们用`Self`来声明参数类型。在月兔中，接口是结构化的，因此我们无需为特定的接口实现方法，只需要类型本身有实现该方法即可。

我们可以在泛型函数的类型参数上添加接口的要求。我们可以限制参数的类型为一个或多个接口，语法为`<类型参数> : <接口>`。而在函数中，我们就可以使用接口定义的方法。最通用的使用方法就是`<类型参数>::<方法名称>`。例如在下面的例子中，我改写了循环队列的初始化方法。接口的限制可以让我们尽早发现使用不存在方法的错误。例如在下面的截图当中，我们试图构建一个`BoxedInt`的队列。但是这个类型并没有定义它的默认值。此时编译器就会及早发现问题，并且指出问题所在。

这里我们同样利用接口重新实现树的添加方法。我们声明类型参数T应当满足比较接口，因为只有这样，使用二叉搜索树才有意义。之后，我们在第六行使用`T::compare`这个方法。我们可以使用这个方法，是因为我们知道`T`满足比较接口，因此它必定拥有比较函数。

方法的定义是通过`<类型>::<函数名>`定义。例如，在第三行，我们给`BoxedInt`类型定义了`default`方法。我们并不需要做任何的特殊声明来实现接口，因为月兔的接口是结构化的，类型有该方法，就满足了该接口的定义。我们在这里使用整数的默认值。最后，我们可以构造`BoxedInt`的循环队列了。

定义方法带来的另一个好处是可以进行链式调用。如果方法的第一个参数与声明的类型一致，我们可以用`<变量>.<方法>`的方式调用该方法，括号中为剩余的参数。如果这个参数名称为`self`，那么我们还可以省略前方的`<类型>::`。这么做的好处在于，当我们要对一个数据进行连续的操作的时候，我们可以避免一层套一层，而是按照操作顺序，更好地理解究竟发生了什么。例如最下方的例子，在第九行，利用链式调用，我们从左到右看便是数据的加工过程。而最下面的实现则是一层套一层，加工过程要从里到外进行理解。如果有大量参数，很难看清楚每个参数对应哪一层的调用。

当然，有的接口的定义比较简单常用。这种情况下月兔可以替我们生成一些接口。常见的例如默认值、判断相等、比较大小、输出调试信息等。我们通过在定义最后添加`derive(<接口>)`名称等。派生的时候，我们需要数据结构内部的参数同样满足这些接口。例如这里`BoxedInt`可以进行派生是因为`Int`已经满足了这些全部的接口。而如果没有，则会产生报错信息。

我们现在来看一个例子，利用接口来实现一个简单的表。表是键值对的集合。例如在下方的键值对中，0对应"a"，5对应"Hello"，7对应"a"。其中对于每一个键存在一个值，值可以重复，键不能重复。我们对于它定义操作如下：我们应当可以创建表；添加键值对或更新键对应的值，并且获得一个新的表；可以获得键所对应的值。当然，因为表中不一定有我们想要查询的键值对，因此我们用`Option`来包裹我们的查询结果。

我们利用列表进行最简单的实现：我们在列表中存储二元组，每次将新的值添加在表头，查询也从表头开始，一旦查到即返回。这样我们查到的都是最新的值。这个简易实现要求我们的键满足相等接口，这样才能比较键判断是不是我们所要查找的值。因此，我们在`get`函数中对类型变量添加接口的定义，限制Key应当可以进行相等的判断。
我们利用列表和二元组进行实现。我们定义一个新类型Map，它的实际值是List[(Key, Value)]。生成这个新类型的表很简单，我们只需要用空列表作为值即可。添加也很简单。我们通过模式匹配取出其中的实际列表，并且在列表前方添加新的键值对即可。
当我们取出的时候，我们需要进行相等判断，因此这里有相等的接口限制。我们在内部用一个简单的辅助函数来对实际的列表值进行递归遍历。当我们找到一个键值对，我们判断键是不是我们所要查询的，这个通过两个等于号来判断。这是因为实现了`Eq`接口，而`Eq`接口的要求是实现相等的自定义运算符。如果找到了，那么我们取出对应的值，并且结束递归。否则，我们继续查找，直到列表最后。可以看到，我们取出的永远是最新添加的数据。

月兔还允许自定义运算符。这个可以通过定义特定名称、类型的方法即可实现。例如，定义一个名称为`op_equal`的方法，两个参数均为方法关联的类型，允许我们使用相等的运算符，而`op_add`则允许我们使用加号。通过自定义运算符，我们可以更好地使用我们自定义的数据类型。目前可以定义的运算符有等于号、加减乘除号、取值、设置、比较等。
我们可以再看一个例子。我们刚才定义了表，通过`get`与`put`函数进行修改操作。但是我们也可以利用运算符来操作，这对于一些其他语言的使用者来说可能更为的友好。我们在这里定义了设值`op_set`和取值`op_get`方法。之后，我们可以用在变量名后使用方括号，方括号中使用索引值的方式来获取对应的值，而如果后面添加了等号，那么就变成了设值。就像下面的例子当中。设值语句也是一个表达式，返回值便是`op_get`定义的返回值，因此我们可以用这种方式来获取更新后的值。当然，我们也可以对于可变数据结构直接进行原地的修改，不返回任何的值。

总结。本节课我们展示了如何在月兔中定义接口并修饰类型变量，以及如何实现方法及自定义运算符。我们同时还展示了一个简单的表的实现。
