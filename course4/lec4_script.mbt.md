# 现代编程思想：多元组，结构体与枚举类型

大家好，欢迎来到由IDEA研究院基础软件中心为大家带来的现代编程思想公开课。今天的主题是多元组，结构体与枚举类型。一言以蔽之，今天介绍如何在月兔中自定义数据结构。

# 回顾：多元组

首先让我们来回顾第二节课已经介绍过的月兔基础数据类型：多元组。

多元组是固定长度的不同类型数据的组合。相比较之下，列表则是任意长度的相同类型的数据的集合。例如，下方的列表长度不定，但是存储的值必须都是字符类型。上节课没有提到`Cons`为什么要叫`Cons`，是因为它是`Construct`的缩写，在这里补充一下。
多元组的定义通过括号包裹，逗号分隔的表达式组成，类型也是相同的语法，例如我们这里看到的身份信息的定义。
多元组的成员的访问可以通过索引访问，从左到右索引从0开始，例如`(2023, 10, 24).0 == 2023`。

# 笛卡尔积
大家或许了解过笛卡尔积。两个集合的笛卡尔积，便是一个集合，其中所有的元素便是原来两个集合元素构成的有序对。例如这里扑克牌的花色的集合与1到52的数字构成的笛卡尔积，便构成了所有花色与数字的有序对。而多元组，不仅仅是两个集合的笛卡尔积，是多个集合的笛卡尔积，因此更确切的说法是构成的有序元素组。也因此，多元组又被称为积类型。那么大家可能会好奇，有积类型，那么有和类型吗？有积类型和和类型，那有零有一吗？我们会在稍后的课程中为大家介绍。

# 结构体

元组的问题在于，难以理解其所代表的数据。举例来说，`(String, Int)`，究竟代表一个人的姓名和年龄？还是代表一个人的姓名和手机号？亦或是地址和邮箱？

结构体允许我们赋予**名称**，即是赋予名称给整个类型，也是赋予名称给每个字段，例如
- `struct PersonalInfo { name: String; age: Int }`
- `struct ContactInfo { name: String; telephone: Int }`
- `struct AddressInfo { address: String; postal: Int }`
通过名称，我们能明确数据的信息以及对应字段的含义。

结构体的定义形如`struct <结构体名称> { <字段名>: <类型> ; ... }`。例如：`struct PersonalInfo { name: String; age: Int}`。分号我们刚才提过了，在换行的情况下可以省略。
定义结构体的值时候，是用大括号包裹，给每一个字段赋值：`<字段名>: <值>`；字段赋值后跟着一个逗号，如：`let info: PersonalInfo = { name: "Moonbit", age: 1, }`。大家注意到每个值后都有逗号。如果最后一个逗号后面直接跟着大括号未有换行，则最后一个逗号可以省略。这里的定义不在意顺序，例如`{ age: 1, name: "Moonbit" }`。如果两个结构体碰巧字段名称和类型完全相同，只定义了值是无法区分的；此时我们可以在结构体的值的后面加上类型声明，例如`: A`来进行区分。

结构体的访问可以通过类似多元组的方法访问，通过字段名获取对应数据。例如`.age`来获得`age`所对应的数据。在根据已有结构体创建新的结构体的时候，如果我们有个非常大型的结构体，那么重新声明每个字段显然是非常费时费力的。为了方便起见，月兔也提供了仅更新部分字段的功能。只需要在结构体值的定义前用`.. <原结构体>`标明基于哪个结构体，之后便只需要声明重新修改过的值对应的字段即可。如下方的例子。

# 多元组与结构体的关系

大家可能会发现，多元组和结构体似乎非常相像。事实上，一个结构体与相同类型集合构成的多元组是同构的关系。同构，也就是两个集合之间存在着一一映射的关系。在集合`A`与`B`之间存在一对映射关系`f: (A) -> B`以及`g: (B) -> A`，且对于任意的`a`与`b`有`g(f(a)) == a`和`f(g(b)) == b`，也就是如下图所示，那么这两个集合就是同构的。举例来说，`PersonalInfo`与`(String, Int)`就是同构的，因为我们可以构筑如下的一对映射：
 ```moonbit
fn f(info: PersonalInfo) -> (String, Int) { (info.name, info.age) }
fn g(pair: (String, Int)) -> PersonalInfo { { name: pair.0, age: pair.1, }}
```
大家可以尝试着验证一下。同理，`PersonalInfo`与`(Int, String)`也是同构的，大家可以尝试自行定义一对映射。

多元组和结构体的区别则在于，多元组是`structural`，也就是只要结构相同，即字段类型一一对应，那么类型就是兼容的。例如此处，函数成功接受了一个多元组。而结构体不同。结构体是`nominal`，也就是只有类型名相同，类型才是兼容的（而内部定义的顺序可以打乱）。例如第一个例子中，即使结构是完全一致的，但两者的类型名称不相同，函数无法接受这个结构体。而第二个例子中，虽然结构的顺序是不同的，但是因为类型相同，函数可以顺利接受。

# 模式匹配

让我们接下来梳理一下模式匹配，来看看多元组和结构体除了通过下标和字段名访问以外的另一种方式。

我们回顾一下，之前我们用模式匹配查看了列表和Option的结构。例如，Nil和Cons来匹配列表，None和Some来匹配Option。事实上，模式匹配可以匹配值（逻辑值、数字、字符、字符串）以及构造器。上面的例子中，我们便是匹配了数字。注意到，如果是匹配值，我们还可以用竖线来分割模式，同时匹配多种可能的值。最后我们则用下划线这一通配符匹配所有的剩余的情况。在构造器中，我们也可以嵌套模式进行匹配，或者用标识符绑定对应结构。例如，第一个`Cons`便是用数字0来匹配所有以0开头的列表，而第二个`Cons`则是用通配符和标识符来匹配剩下的任何列表，同时将列表的子列表绑定到`tl`这个标识符上，以便进行进一步处理；而当前列表的值则是因为使用了通配符而被抛弃。

对于多元组和结构体而言，模式匹配与构造的形式颇为类似。多元组的模式便是小括号包裹，逗号分隔。匹配时需数量一一对应。结构体匹配则是大括号包裹，逗号分割。如果需要匹配其他模式或者自定义其他的标识符，则需要用字段名加冒号，例如`age: 0`，否则可以直接使用字段名作为标识符。匹配的时候，可以忽略部分字段，在最后用`..`即可。

现在让我们来看一个用到了多元组模式匹配的例子。在这里，我们尝试缝合两个列表，像拉链一样，将它们组合在一起，构成的是列表中元素两两组合构成的元素对的列表，以更短的列表长度为准。例如例子中，两个列表分别为：1、2、3和a b c d。那么缝合后的列表则是(1, a) (2, b) (3, c)。于是我们便可以定义我们的函数，接受两个列表，返回一个列表。在这里，我们通过构造二元组再匹配二元组嵌套模式的方式，利用模式匹配，同时匹配两个列表。只有当两个列表都为非空列表，我们构建一个非空列表，首项即为两个值构成的有序对，后续则是两个列表的子列表的缝合结果。如果是其他情况，那么至少有一个列表为空，结果为空，因此我们用通配符一起匹配了。需要注意的是，正如上节课所说，模式匹配的顺序是从上到下，因此如果通配符在上了，则之后的模式永远不会被匹配到，代码也永远不能被运行。好消息是，月兔可以检查出这种情况，并且提示我们。这种仅仅是警告，而不会阻止编译，因此要注意IDE的问题面板的内容。

最后，模式匹配不仅可以用在`match`中，还可以用在数据绑定中。在本地定义中，我们可以利用模式匹配表达式，并且将对应的子结构绑定到标识符上。需要注意的是，如果在这个时候进行值的比较，那么如果匹配失败，程序一样会出现运行时错误，从而导致程序中止。

# 枚举类型

接下来让我们进入枚举类型的学习。

一个问题是，我们应该如何表示不同情况的并集？例如，如何定义一个类型表示周一到周日的集合？如何定义一个类型定义硬币落下结果的集合，也就是正反面？如何定义一个类型表示整数四则运算的结果的集合，例如成功获得结果，计算溢出，除数为零等？

答案：枚举类型。我们使用枚举类型，来定义表示不同情况的数据结构。例如，我们在这里定义了一周七天的集合。下方则定义了硬币的正反面。

枚举类型的构造如下：
`enum <类型名称> { <情形>; }`
其中，每一种可能的情形即是数据的构造器。例如`let monday = Monday`，这里的`Monday`就定义了星期一。不同的枚举类型之间可能产生冲突，因为它们可能用了相同的方式命名了一些情况。此时我们可以在构造器前方加上`<类型>::`加以区分。

那看到一周七天的枚举类型，有的人可能问，为什么我们要定义枚举类型呢？为什么我们不能直接用数字一到七来分别对应周一到周日呢？我们可以来对比一下以下两个函数。最显著的区别在于，用枚举类型定义的函数是完全函数，而用整型定义的函数是不完全函数，这就增加了用户传入错误输入的可能性：用户可能传入-1，传入8，而我们没有办法通过编译器阻止这一点。另外一点就在于，星期几加一有什么含义？星期几乘以几有什么含义？那星期一乘以二为什么是星期二呢？星期二除以二为什么是星期一呢？枚举类型可以与现有的类型区分开，更好地实现抽象。

同时，枚举类型也可以禁止不合理数据的表示。例如，我们在使用各种服务的时候，通常需要用邮箱注册或是手机注册。那么用户身份的标识符即可以是手机，也可以是邮箱，这两个都是可选项，但是必须有且仅有一个。如果我们用一个结构体，两个可空来表示，那么很可能出现两个字段都为空，或者两个字段都有数据这两种情况，而这不是我们想要的。因此，我们可以使用枚举类型更好地限定合理数据的范畴。

枚举类型的每一种情况也可以承载数据，例如我们看到过的`Option`便是一个枚举类型。此时只需在情况后用小括号包裹逗号分隔，定义参数的类型即可。例如第二个例子中，我们定义了整数运算成功的情况，此时值为整数。枚举类型对应的是可区分的并集。什么意思呢？首先它是一个不同情况对应的并集，例如`Some`对应的类型`T`所代表的集合以及`None`这个单个值定义的集合；其次，这个集合是可以区分的，因为每个情况被情况的名称所区分。即便有两种情况，每个情况所包含的数据类型相同，它们也完全不相同。故此，枚举类型又被称为和类型。

# 代数数据类型

即然提到了积类型、和类型，让我来简单介绍一下代数数据类型。需要声明的是，这里的代数数据类型的介绍十分粗浅，欢迎大家参考课后的拓展阅读资料。

我们刚才提到的多元组、结构体和枚举类型被统称为代数数据类型，因为它们通过代数运算，也就是“和”与“积”构造类型，也因为它们具有代数结构。回想一下普通的数，我们有相等的判断，相乘相加的运算，以及任何数乘以1都等于本身，任何数加0都等于本身等等性质。类似的，在代数数据类型中也有：类型相等即意味着类型对应的集合是同构的；类型相乘即构成积类型，如多元组或结构体；类型相加即为和类型，如枚举类型。零在这里是一个类型，它对应着空的类型。我们可以通过一个没有定义任何情况的枚举类型，这样的类型没有任何的构造器，没有人可以构造出任何一个属于这个类型的值，因此它是空的。而一在这里是一个对应只有一个元素的类型，我们称之为单值类型Unit，它的值即是一个零元组。

我们可以来验证一下之前提到的性质：任何数乘以1都等于本身，任何数加0都等于本身。
任何数乘以1都等于本身在这里便意味着，对于任意类型`T`，`(T, Unit)`与`T`同构。我们构造一组映射：从`T`到`(T, Unit)`非常简单，只需添加零元组即可。反之亦然，只需忽略零元组即可。大家可以直观地感受到它们是同构的。而任何数加零都等于本身在这里则意味着，对于任意类型，我们定义一个枚举类型`PlusZero`，其中一种情况包含类型为`T`的值，而另一种情况则包含类型为`Nothing`的值；这个类型与`T`同构。我们同样可以构造一组映射。从`PlusZero`开始，我们用模式匹配分情况讨论。如果其中包含的值类型为`T`，则直接映射为`T`。如果类型为`Nothing`，那么事实上这种情况根本不会发生，因为没有任何的值的类型是`Nothing`，因此我们采用`abort`来定义这种情况，也就是程序会中断；而反之，我们则只需要将`T`用`CaseT`包裹即可。还是要强调，这里的介绍非常粗浅，只是给大家一个直观的感受。有兴趣的同学可以进行拓展学习。

这里还有几个例子。我们定义的硬币的数据类型，可以看作是1+1，因为每一个情况：`Head`和`Tail`，事实上都是只有一个值的集合，因此它们每一个都和单值类型同构；用和类型结合起来的`Coin`类型就是1 + 1 = 2，是一个有两个值的集合，它也与其他任何有两个值的类型同构。同样地，`DaysOfWeek`就是有七个值的集合，与任何有七个值的类型同构。而比较有趣的是`List`，我们这里以`List[Int]`为例。`List[Int]`的定义是，空列表或者一个整数和一个子列表，而空列表同样与单值类型同构，因此可以写作`1 + Int * List`。而这里的`List`是递归的，因此可以被替换为`1 + Int * List`。之后，我们可以使用乘法结合律，获得`1 + Int * 1 + Int * Int * List`。继续进行替换与化简，于是我们便可以发现，整数的列表的集合，是一个单值集合、一个整数集合、两个整数集合的笛卡尔积乃至无数整数集合的笛卡尔积的可区分并集。而这也符合事实。

# 总结

本章节介绍了月兔中的诸多自定义数据类型，包括
	- 多元组
	- 结构体
	- 枚举类型
同时介绍了代数数据类型的概念。

我们推荐大家阅读Category Theory for Programmers第六章