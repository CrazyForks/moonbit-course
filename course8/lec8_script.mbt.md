# 现代编程思想：队列，可变数据结构实现

大家好，欢迎来到由IDEA研究院基础软件中心为大家带来的现代编程思想公开课。上节课我们学习了命令式编程，了解了可变数据结构、循环与递归的关系等。这节课，我们利用可变数据结构，重新定义我们之前见过的数据结构：队列。

我们之前介绍过队列这一数据结构，它是一个先进先出的数据结构，也就是先放入队列的最先被取出。我们曾经演示过如何利用两个堆栈来实现一个队列。那个实现是函数式的实现，数据都不可发生变化，每一次修改都是在创建新的数据。而这次，我们将要展示如何利用可变数据结构进行实现，直接在原有的数据基础上进行修改。我们将会展示两个实现：一个是基于数组的循环队列，另一个则是单向链表。

我们对队列所要实现的函数定义如下。我们关心算法的实现，因此我们以整数队列为例。我们首先需要能够创建空列表。之后，我们需要能够添加元素、删除元素，以及查看当前列表最前端的元素。最后则是查看列表长度的功能。其中，`pop` `push`都将在原来的列表的基础上直接进行修改。我们为了使用方便，将修改过的列表作为返回值传回。这样，我们可以进行链式调用。

我们首先来看循环队列。我们可以利用一个数组来代表队列。数组是一个连续的存储空间，其中每一个字段都可以被修改。一个数组一旦被分配以后长度不变。在下面的例子中，我们分配了一个长度为5的列表，其中每一个字段都被设为0。之后，我们对第一个和第二个数据进行修改，分别改为1和2。之后，我们对它进行输出操作，获得了`[1, 2, 0, 0, 0]`。大家可以注意到，数组的下标是从零开始的。大家稍后就会看到这么做的好处。

用数组实现的时候，我们记录当前列表的开始和结束的下标。之后，每当添加新的元素时，我们将代表结束的坐标向后移动，如果超出数组长度，则再绕回开头。现在大家看到的就是添加的演示。首先，我们创建一个空的队列。此时，列表的开始和结束都指向第一个元素。之后，我们进行添加操作。我们将元素添加到`end`所指向的位置，也就是第一个元素处，并且修改列表的结束位置。之后，我们重复同样的操作。而取出操作则是将`start`所在的元素清零，并且将`start`向后移一位。
我们再看一下当接近数组结束的位置时的情形。`end`此时指向最后一个元素的位置。当我们添加元素后，`end`无法向后移动，因此我们将它移动到最前方，这也是为什么它叫循环队列。之后，我们进行两次取出操作。同样地，`start`在超出列表长度之后，也再次回到列表的最初。

下面是一个简易的实现。我们记录了数组、列表的起始与结束以及列表的长度。我们向队列中添加元素时，将元素添加到`end`指向的位置。之后我们利用取模操作将`end`指向队首，并且维护队列长度。问题是，数组的长度是固定的。如果添加元素的数量超出数组的长度该怎么办呢？答案是对数组进行扩容操作。我们首先判断是否需要扩容，也就是列表的长度是否已经等于数组的长度。如果需要扩容，我们创建新的更长的数组，并将原有的数据复制过去，如下方代码所示。其中，在遍历数组的时候，我们同样利用取模操作保证指向数组范围内的元素。最后，我们用新的数组替换原来结构体中的数组。在此之后，我们再次利用常规的添加操作。

当我们取出元素的时候，我们移除`start`所指向的元素，并将`start`向后移，同时维护列表的长度。由于列表的长度一直被动态维护，因此我们直接取出记录即可。

我们希望存储的不止整数。问题在于，当我们创建新的数组的时候，数组中应该放置什么样的默认值呢？这里有两个选项，一个是利用`Option::None`作为默认值，将每一个值都用`Option`包裹；另一个选择则是使用类型自身的默认值。这个默认值如何定义、如何利用，我们将在下一节课讲解。

现在让我们来看单向链表的版本。在单向链表中，每一个节点都存储着一个数据，其中每个数据结构都指向着下一个数据结构，就像锁链一样。由于下一个节点不一定存在，因此我们利用`Option`进行包裹；同时它也是个可变字段，可以在添加新的节点后指向新的节点。我们的链表则存储了一头一尾两个节点。

我们来看一下简单的演示。当我们创建新的链表的时候，头尾均为空。而当我们添加一个数据的时候，我们创建一个新的节点，并将链表的头尾都指向这个节点。之后，我们再次添加节点的时候，我们便需要更新当前尾节点的下一个节点，使它指向之后添加的节点。而链表的尾节点则需要始终指向最新的节点。

我们添加的时候，我们判断链表是否为非空。如果为空，那么头尾均指向它；否则，我们指向队尾添加，并且维护链表的关系。取出元素时，我们只需要简单地修改头节点，让它沿着顺序取下一个节点即可。维护链表的长度有多种方法。一种是像刚才那样在结构体中进行记录，并且在添加删除的时候进行维护。另一种则是临时求值。我们这次演示第二种方式。我们写一个简单的递归函数，从链表的头开始沿着引用链访问所有的节点。请注意这里，`aux`在递归的分支。我们在递归后，需要将结果加一，作为函数运算的结果。这一点就造成了问题。这段代码的问题在于，如果链表太长，我们会观察到“栈溢出”的信息，如下方截图所示。这里溢出的栈是什么，又为什么溢出呢？让我们来运行观察一下。

可以看到，当我们调用函数的时候，我们每次都会在堆栈上添加一个新的环境。而当我们结束计算的时候，这个环境便会被消除掉。这个后进先出的结构就是一个堆栈。但是，计算机的内存大小是有限的。如果我们放任这个堆栈不断增长，那么我们便会超出内存限制。当然，如果我们可以让旧的环境无需保留，那么就可以解决问题。要做到这一点，我们需要保证函数的最后一个运算是函数调用，称之为尾调用。而如果最后一个运算是递归调用函数本身，那么我们称之为尾递归。因为函数调用的结果就是最终的运算结果，我们无需再保留当前的运算环境。如下面的代码所示，我们每一次运行的最后一个函数调用便是`aux2`本身，那么我们可以随意运行多少，都不会出现栈溢出。

总结，本章节我们介绍了使用可变数据结构定义队列，包括了循环队列与单向链表两个实现。同时，我们还介绍了尾调用和尾递归的概念。
