# 现代编程思想：哈希表与闭包

大家好，欢迎来到由IDEA研究院基础软件中心为大家带来的现代编程思想公开课。上节课我们学习了表的概念。表是一个键值对的集合，将键映射到值上，其中键不重复。同时展示了一个最简单的基于二元组列表的实现。这种实现在添加或更新的时候向队首添加新的键值对，查询的时候也从队首开始遍历。
另一种表的实现则是基于我们已经介绍过的二叉平衡树。我们只需要基于第五节课介绍的二叉平衡树进行修改，将每个节点存储的数据由一个整数改为键值对即可。在对树操作的时候我们比较存储的键值对的第一个参数与我们想要进行操作的键的大小关系即可。这节课我们来看另一个实现：哈希表。

首先先介绍一下什么是哈希函数。哈希函数，也称为散列函数。它能够将任意长度的数据映射到某一固定长度的数据。举个例子来说，大家可能听说过接触过的MD5算法，可以把各种大小、各种格式、无穷无尽的文件映射到短短的128位的数据上来。在月兔的`Hash`接口中，数据被映射到整形的范围内。例如，左侧这个非常长的字符串，会被映射为右侧的整数。哈希表就是利用这样的映射，在将数据映射到哈希值以后，再将哈希值映射到数组索引中，进行快速的添加、查询、修改，因为在现代的计算机中，对于数组的随机访问是效率最高的操作。在理想情况下，对于哈希表的各类操作均为常数时间，也就是说，操作的时间消耗不随数据量的增大而增大。相对而言，二叉平衡树的操作则是对数时间增长。下面的伪代码展示了哈希表的使用。理想情况下，我们有一个数组，其中装着键值对。我们现在要对它进行添加或更新或查询。我们首先根据要操作的键值计算出哈希值。哈希值的范围是所有整数，因此，之后我们根据这个哈希值取模映射到数组索引上，基于这个索引我们可以进行取值、修改操作。当然，正如之前所说，这是一个理想情况，之所以说它理想就是因为会出现哈希冲突。

相信大家都知道抽屉原理，或者生日问题，或者鸽巢原理。不管叫什么，我们都清楚，我们所映射的数据的数量可能大于整数所能表示的范围，而整数所代表的哈希值的范围又可能远大于数组的索引——显然，我们不可能直接分配一个21亿大小的数组。那么在这种情况下，就会出现多个数据的索引相同从而产生冲突。所以，便有了多个解决方案来协调哈希冲突。其中一个解决方案是直接寻址，一个数据一定要放到它所计算出来的数组的对应索引的格子中去。这种情况下会有多个数据放在一个格子里，怎么想都放不下吧？所以，就在同一个索引下定义另一个数据结构，来装所有相同索引的数据。这些数据结构可以是列表，也可以是二叉平衡树等，数组于是变成了列表的数组或树的数组。另一种方案则是不改变数组的类型，也就是说，数组仍然是直接装数据的数组，不过，我们遵循一些规则，另寻空位将数据放入数组中。例如，线性探查便是从应当放入的位置开始向后查找，将数据放进第一个空位中。除此以外，也有二次探查，即每次不是递增，而是增加平方等。这里就不详细介绍。那么我们今天分别来看基于列表的直接寻址和基于线性探查的开放寻址。

首先我们从较为简单的直接寻址开始。简单来说，就是定义一个列表的数组。当数据将要被添加进来，则计算它们的哈希值及对应索引，最后将数据添加到索引对应的列表之中。

在这里，我定义了两个额外的数据结构。首先是一个键值对，其中值是可以原地更新的，方便我们进行更新操作。之后，定义一个可以原地修改的链表。其中的值若为空则相当于空列表，若非空，则相当于列表的头元素以及剩余的列表。最后则是我们的哈希表的定义。首先是一个存放列表的数组，列表中存放了键值对。之后，我们动态维护数组的长度于键值对数量的属性。

当我们进行添加更新操作的时候，我们根据键的哈希计算出应当存放的位置，之后遍历集合查找键。如果找到，那么我们修改对应的值，否则则添加键值对。删除操作也是类似的流程，先查找对应的集合，然后再修改集合。

这里展示的是添加/更新的代码。可以看到第二行我们首先计算了键的哈希值。为了能够计算这个值，键应当实现哈希接口，如第一行所示。之后我们找到对应的数据结构，并且进行遍历。这里我展示了使用可变数据加上循环的操作。我是用一个死循环，在其中根据是否查找到对应键或是找到列表终点来进行`break`操作跳出循环。之后的操作就很简单了，如果到队尾了都没有找到，那么我们在队尾进行原地更新，添加新的一对数据。如果找到了，那么我们更新数据。否则，我们将`bucket`替换为剩余的队列，确保循环过程中数据都在变为更小的结构，循环会终结。在最后，我们根据当前的负载进行判断，是否要对哈希表进行扩容。

大家可能会奇怪，为什么用了会不断增长的列表还要进行扩容，这又不是循环数组。这里就牵扯到哈希表的负载，也就是哈希表的键值对数量与数组长度的比值。我们可以简单理解，如果负载上升，那么哈希冲突也会不断增加，链表的长度也会不断增长，增查盖删的操作时间也会随着变长。这就不符合我们最初定义哈希表的初衷，那就是利用数组进行快速操作。追求常数的操作时间。因此，我们需要设定一个阈值，如果负载超过阈值，我们就重新分配更大的数组，以此来降低链表的长度。但是，阈值不宜过高也不宜过低。如果阈值过高，那么出现较长链表的可能性就会增大，查找遍历链表的时间会变长，性能会下降；如果阈值过低，那么重新分配数组、重新给每一个数据计算哈希放入新数组的时间也会变长。

接下来我们简单过一下删除操作。与添加/更新操作类似，我们计算哈希与索引，找到对应数据结构，并进行遍历。如果遍历完成，那么我们推出循环。否则，我们判断是不是我们要找的数据结构。如果是，我们原地进行修改，将当前存储值从列表中抹去，并维护哈希表大小。否则，我们继续遍历查找。直接寻址的查找、扩容操作比较简单，就留给大家作为训练。

我们接下来看一下开放寻址的实现。回忆一下我们刚才介绍的线性探查。如果发生了哈希冲突，我们将索引递增，向后查找，直到找到空位放入。例如在下面的示意图中，我们首先插入0。它的哈希值是0，因此添加到索引为0的位置。之后，我们添加1。它的哈希值是0，因此添加到索引为1的位置。最后，我们添加5。它的哈希值是5，而5超出了索引值的范围，因此我们进行取模操作，获得了0。理论上，它应该被放在索引为0的位置，但是这里已经有0了。于是我们将索引递增，此时已经有1，于是我们继续递增，直到第一个空位，也就是索引为2的位置放入。需要注意的是，在这种存放模式下，我们需要维护数组的一个性质，那就是，键值对应当存放的位置与实际位置之间不存在空位。这是一个约定，否则的话，如果我们想要查找一个键值对，它可能存在于任何位置，确认一个键值对不存在需要遍历整个哈希表，这显然又是不能接受的性能损耗。因此我们保证键值对实际位置与应当存放的位置之间没有空位，这样当我们查找的时候找到空位就可以停下。

对于开放寻址的实现，我们这里选择采用基于默认值的数组，和上节课展示的循环队列的实现类似。基于`Option`的实现大家可以自行尝试。除了存放键值对的数组以外，为了区分当前位置是否为空，我们还有一个布尔值的数组。最后，我们同样动态维护数组的长度以及键值对的数量。

在添加更新操作的时候，我们根据哈希值计算出对应的索引值。之后，我们查看数组中的该位置，如果被占用，那么我们判断是不是我们要找的键。如果是，我们更新值，否则，向后继续查找。如果我们找到了空位，那么我们就存放键值对。我们在这里默认空位的存在，我们会根据数组的使用情况进行扩容操作。注意这里的所谓“向后”与循环队列相同，如果超出了数组的长度那么就回到数组的最初。

我们定义一个辅助函数来确定键是否存在。如果存在，那么返回键的索引；如果不存在，那么我们返回第一个空位所在的位置。基于这个辅助函数，我们定义添加、更新操作。我们根据计算出的索引值是否有值判断是找到了对应的键还是找到了空位。如果找到了对应的键，那我们更新对应的值，否则将键值对加入空位，这包括更新位置的占用情况、修改数组中的数据、动态维护哈希表大小。最后，我们判断是否需要进行扩容。

添加的操作十分简单。相对而言，删除的操作就比较麻烦了。不要忘了我们有一个性质需要维护，那就是键值的实际存放位置与应当存放的位置之间不能存在空位。如下图所示，我们在添加0、1、5、3后删除1。5在这里就是一个因为对应索引存在元素而不得不向后存放的例子。则此时5到索引0之间出现了空位，不变性被发生了破坏，我们无法通过搜索找到5。一种简单的方式是通过定义一种特殊的状态，也就是不仅仅标注一个位置是否被占据，还标注是否被删除，以此确保后续的数据依然可以被正确地查询到。另一种方法是对当前被删除的元素直到下个空位之间的元素进行检查，判断是否需要移动使得不变性得到维护。我们这里展示最简单的标注做法，也被称为“墓碑”。

我们定义一个新的状态的枚举类型，包括“空”、“被占据”以及“被删除”，并且将哈希表内的状态也进行对应的修改。我们需要修改我们之前的辅助函数的逻辑。在查找键或空位的时候，我们需要记录遇到的第一个可以存放的空位，`Empty`或`Deleted`来重新利用被删除元素留下的空位。但是我们查找的时候仍然需要找到`Empty`为止来确定键是否存在。我们利用一个简单的`empty`变量来记录，当它为负值，说明我们还没有找到空位，而如果我们找到任何一个空位，那我们更新`empty`为空位的索引。如果循环结束，那也说明我们找到了空位，我们根据`empty`状态决定返回哪一个。删除操作就变得十分简单，只需要根据辅助函数，在返回的格子被占用的情况下，进行重新标记即可。需要注意的是，使用这种方案在多次添加删除时，会存在较多“已删除”标记。而我们查找元素的访问的路径上也会出现大量额外的开销，增加额外的查询时间。因此，我们需要在一段时间后进行重新排列。

接下来我们简单介绍另一种方案，也就是在每次删除后进行重新移动，压缩查询路径。我们还是以添加0 1 5 3并删除1为例。对于1之前的元素，我们可以判断不变性不会发生变化，而1之后的元素我们无法确定。这些元素既有可能是原本就应该被分配到这里，也可能是因为空位被占据而向后顺延放到了现在的位置上。因此需要进行检查。我们首先检查5。我们可以看到，5本来应该被分配在索引0的为止，为了解决哈希冲突，它被放置在如今的位置上。而现在前方的1被删除，它与索引0之间就产生了空白。这就破坏了不变性。因此，我们需要将5进行移动，提前到1原本占据的位置。之后我们再对3进行检查，因为3在没有哈希冲突的情况下就应该存放在这里，所以我们对3不进行任何的操作。而在3之后，我们遇到了空位。在空位之后的元素不会受到影响，因此我们停止我们的检查。

我们再来看一个例子。我们假设一个长度为10的数组，因此以n结尾的数字的哈希取模后获得的索引就是n，例如0的索引是0，11的索引是1，13的索引是3等。我们同样删除索引1的数据，重新移动哈希表中的元素。我们对于索引1到5的位置进行检查。首先是11，在没有哈希冲突的情况下，它应该被存放在索引1的位置。现在这个索引成了空位，因此我们将11给挪到空位所在的位置。之后，我们检查3.3就在它所应该在的位置，因此我们不对3进行任何操作。之后我们检查21。21在没有哈希冲突的情况下，应该被分配在索引1的位置，而现在它到索引1之间出现了空位，也就是我们挪开11以后留下的。因此，我们把21也给向前移动。最后我们检查13。在没有哈希冲突的情况下，它应该被分配在3的位置，现在这两个位置之间出现了移动21后的空位，因此我们也将13向前移动。可以看到，移动以后，所有的元素都符合不变性，即在没有哈希冲突情况下的索引与实际存放位置之间不存在空位。这个算法的具体的实现留给大家作为练习。

接下来，让我们进入今天最后的主题，闭包。什么是闭包呢？闭包是一个函数以及它所捆绑的周边环境状态的引用的组合。它的环境状态由词法环境决定。例如在下方的代码中，在第三行我们定义函数的时候，可以看到此处的`i`对应的是第二行的`i`。因此，之后当我们使用`debug_i`的时候，它所输出的都是第2行的`i`的值。我们在第4行进行修改，此时再次执行的话输出也会进行对应的修改。而第7行，我们定义了另一个`i`。虽然名称相同，但是与我们的闭包毫无关联，因此输出不会发生任何变化。闭包所捕获的环境与程序的结构对应，在代码定义的时候决定，而不是在运行时决定。

那么闭包有什么用呢？一种可能的用法是封装数据和行为。我们在一个函数中定义一个变量，这个变量的作用域就是这个函数，在其他地方的程序无法直接访问它。我们通过定义两个捕获了这个值的函数作为返回值来让使用者进行读写操作，如第4、5行所示。特别的，我们还可以在这些函数中加入对于数据的校验。如果我们直接定义一个为一个结构体的可变字段，那么使用者可以为所欲为，而在这里，我们就可以过滤合法的输入。最后我们返回这两个函数。在使用的时候，我们可以看到，如我们所期待的那样，合法的输入会透过函数修改捕获的变量，并且在使用`get`的时候反映出来，而不合法的输入则会被过滤掉。

通过这个技术，我们还可以利用闭包与结构体封装表的行为，定义一个抽象的数据结构。我们之前展示了开放寻址与直接寻址的两种实现，但是对于使用者而言，这并不重要，因为使用方法、使用效果都是相同的。在这种情况下，我们定义一个结构体，它包含四个函数。这些函数都捕获了同一个表，可以进行修改。之后，我们提供两个创造该结构体的函数，分别提供了开放地址实现与直接寻址实现。我们还可以提供简易列表实现或树实现等，这就留给大家进行练习了。最后，我们可以使用这个结构体。只需要替换初始化函数，剩下的代码完全不用修改，就可以使用不同的实现。在这里展示一下大致的代码框架。我们在函数内定义了`map`这个表的实现，之后，我们在多个函数中捕获它，并且将这些函数存入一个结构体中并返回。我们还可以基于结构体进行方法的拓展，方便使用。例如，结构体提供了获取键值对数量的函数，我们就可以添加一个额外的判断表是否为空的方法；结构体提供了获取对应值的函数，我们就可以借此判断表中是否存在对应键等。可以看到，通过这种方式，我们一次给多个实现同时添加了同一套逻辑。

总结，本章节介绍了哈希表的两种实现：开放寻址、直接寻址。同时，我们还介绍了闭包的概念以及利用闭包进行封装操作。在这里推荐大家阅读《算法导论》或《算法》，更好地理解算法的具体内容。那么以上便是本节课的全部内容。
