# 现代编程思想：函数、列表与递归

大家好，欢迎来到由IDEA研究院基础软件中心为大家带来的现代编程思想公开课。今天的主题是函数、列表与递归。

## 基本数据类型：函数

让我们先从作为基本数据类型的函数开始。

在数学上，函数是描述对应关系的一种特殊集合。例如大家可能都知道的一元二次函数、对数函数、三角函数等。它们的一大特点是，对于特定的输入，总是有特定的输出。请大家记住这一特点，我们之后还会再回顾。

在计算机中，我们使用函数来对相同的运算进行抽象，避免大量重复定义。例如，我想要计算半径为1的圆的面积，可以写作：`3.1415 * 1 * 1`。同样地，如果要求半径为2的圆的面积，可以写作：`3.1415 * 2 * 2`。那么半径为3呢？半径为4呢？每一次都要重复写`3.1415 * 半径 * 半径`吗？大家在写程序的时候，如果一个任务或者模式重复出现了三次以上，就可以开始考虑对它进行抽象了。

大家可以对比一下使用与未使用函数的情况。
```rust
let surface_r_1: Double = { let r = 1.0; pi * r * r }
let surface_r_2: Double = { let r = 2.0; pi * r * r }
let surface_r_3: Double = { let r = 3.0; pi * r * r }
let result = (surface_r_1, surface_r_2, surface_r_3)
```

我们定义了面积函数，对重复的运算过程进行了抽象：给定半径，计算代表面积的值。

```rust
fn area(radius: Double) -> Double { pi * radius * radius }
let result = (area(1), area(2), area(3))
```

### 顶层函数的定义

我们首先来看顶层函数的定义，也就是在文件结构最外层的函数的定义。顶层函数的定义为：`fn <函数名> (<参数名>: <类型>, <参数名>: <类型>, ...) -> <类型> <表达式块>`。其中，参数可以有零或多个。这样的类型声明可以让我们关注于函数的接口，而不是函数的具体实现。例如：

```rust
fn one () -> Int {
  1
}

fn add_char(ch: Char, str: String) -> String { 
    ch.to_string() + str
}
```

显然，参数名不能重复定义。

### 函数的应用与计算

当函数定义后，可以通过`<函数名>(<表达式>, <表达式>……)`的方式**应用**函数，例如`one()`与`add_char('m', "oonbit")`。当应用函数时，表达式与函数定义时的参数数量应当相同，且类型一一对应。一一对应的意思就是说，顺序不能打乱：~~add_char("oonbit", 'm')~~

在计算应用函数的表达式时，我们首先要从左到右计算定义了参数的表达式的值，然后用这些值替换函数内部出现的参数，并最终简化表达式。让我们来看一个例子。

```rust
fn add_char(ch: Char, str: String) -> String { 
  ch.to_string() + str 
}

let moonbit: String = add_char(Char::from_int(109), "oonbit")
```

&nbsp;     `add_char(Char::from_int(109), "oonbit")`  
$\mapsto$ `add_char('m', "oonbit")`            因为`Char::from_int(109)` $\mapsto$ `'m'`  
$\mapsto$ `'m'.to_string() + "oonbit"`     替换表达式块中的标识符  
$\mapsto$ `"m" + "oonbit"`                                因为`m.to_string()` $\mapsto$ `"m"`  
$\mapsto$ `"moonbit"`                                           因为`"m" + "oonbit"` $\mapsto$ `"moonbit"`  

### 部分函数

函数定义域有的时候是输入类型的子集，因此可能会有对于输入未定义输出的情况。以下是两个例子：

```rust
let ch: Char = Char::from_int(-1) // 不合理输入：-1在统一码中不对应任何字符
let nan: Int = 1 / 0 // 不被允许的操作：运行时出错并终止
```

一个例子是，将整数转化为字符时，传入负数。这是不合理输入，因为统一码并没有定义负数所对应的字符。另一个例子是整数除法除以零。虽然它们都符合函数的输入参数的类型，但这是不被允许的操作。

对于这种函数，我们称为**部分函数**（Partial Function）；相对的，函数对类型的每个值定义了输出的，我们称为**完全函数**（Total Function）。

为了避免程序运行时因不被允许的操作中止，也为了区分对应合理与不合理输入的输出，我们使用`Option[T]`这一数据结构。

`Option[T]`分为两种情况：
- 无值：`None`
- 有值：`Some(value: T)`

例如，我们可以用`Option`定义一个整数除法的完全函数
```rust
fn div(a: Int, b: Int) -> Option[Int] {
  if b == 0 { None } else { Some(a / b) }
}
```

其中，若b为零，没有对应的输出，我们采用`None`作为返回值；而如果是其他情况，则用`Some`包裹结果加以返回。

Option后的`[T]`代表`Option`是一个泛型类型，包含的数值类型为类型参数`T`，如
  - `Option[Int]`：可能有的值类型为整数

我们将在稍后看到如何获得`Some`中的值

### 局部函数的定义

说完了顶层函数，让我们来看看局部函数。局部函数的定义要求简化了不少，因为很多时候，月兔可以通过函数的定义以及应用时的类型来对函数的类型进行推断。因此，我们大多数时候可以省略参数类型和返回类型，有的时候甚至可以省略函数名称，此时可称为匿名函数。如：

```rust
let answer: () -> Int = fn () {
  fn real_answer(i) {
    42
  }
  real_answer("Ultimate Question")
}

let x: Int = answer() // 42
```

我们定义了一个匿名函数，并将其绑定到`answer`上。这个匿名函数省略了返回值，我们可以根据它的定义来推断。它的定义调用了另一个局部函数`real_answer`。可以看到，这个函数也没有声明输出类型，但我们可以通过42来推断它输出一个数字。它的输出并不取决于输入，且输入亦未声明具体的类型。但当我们传入字符串“终极问题”后，我们可以看到月兔将它推断为了`(String) -> Int`。大家可以试试将传递的字符串改为其他东西，例如数字、字符、元组等。但是需要注意的是，仍然需要有且有一个参数。

函数在月兔中是“一等公民”：可以将函数作为参数、返回值，亦可以绑定或存储函数。我们将在后续课程中深入学习。

### 函数的类型

函数类型的定义为：`(<参数类型>, <参数类型>, <参数类型>, ...) -> <返回值类型>`，如：
- `() -> Int`
- `(Int, String, Char) -> Int`
- `((Int, Int, Int)) -> (Int, Int, Int)` 接受一个元组并返回一个元组

其中，这里的箭头是右结合的，因此最后一个情况中右侧的括号可以省略。

## 列表

接下来让我们进入列表的学习。在生活中，我们会遇到很多数据，其中一些数据有如下的特征：
- 数据是有序的
- 数据是可以重复的
- 数据的数量是不定的

举例来说，我们说的话中的文字，有序、可以重复（叠词词，虽然有的人觉得恶心心）、数量不定。又比如DNA序列片段，有序、四个碱基重复出现，片段长短不一。为了在计算机中表示这些数据，我们定义了列表这一数据结构。

### 列表的定义

我们在这里定义一个单向不可变列表。也就是说，添加内容时，列表只能往一个方向增长，我们称之为头。同时，列表中包含的内容不能被修改。
回想我们第一课所介绍的流程，让我们来定义它的接口，即它所允许的操作：

- 构造
  - `nil : IntList`&nbsp;&nbsp;&nbsp;&nbsp;　　　　　　　　　　返回一个空列表
  - `cons : (Int, IntList) -> IntList`&nbsp;　向列表添加一项
- 解构
  - `head_opt : IntList -> Option[Int]`&nbsp;&nbsp;&nbsp;获得第一项
  - `tail : IntList -> IntList`&nbsp;&nbsp;&nbsp;　　　　获得除第一项以外的项

我们通过一些测试案例来了解接口。

```rust
let empty_list: IntList = nil()
assert(head_opt(empty_list) == None)
assert(tail(empty_list) == empty_list)

let list1: IntList = cons(1, empty_list)
assert(head_opt(list1) == Some(1))
assert(tail(list1) == empty_list)

let list2: IntList = cons(2, list1)
assert(head_opt(list2) == Some(2))
assert(tail(list2) == list1)
```

在月兔中

一个列表可以为：
```rust
enum List[T] {
  Nil // 一个空列表
  // 或
  Cons(T, List[T]) // 一个类型为T的值以及元素类型为T的子列表
}
```

我们可以看到，列表的定义是归纳的。需要注意的是，这里的“归纳”是数学归纳法的归纳，而不是从经验中归纳总结规律的归纳。它属于严谨的演绎推理法。让我们回想一下，数学归纳法首先证明在一个起点值时命题成立，之后证明从一个值到下一个值的过程有效。类比到列表，我们定义了列表为空的数据结构`Nil`。之后，我们定义了当列表添加了一个值的时候的数据结构`Cons`。下图展现了列表的结构：

![](./list.drawio.png)

让我们来看一些列表的例子：
- 以下是列表
    - `let int_list: List[Int] = Cons(1, Cons(2, Cons(3, Nil)))`
    - `let char_list: List[Char] = Cons('一', Cons('句', Cons('话', Nil)))`
- 以下不是列表
    - `Cons(1, Cons(true, Cons(3, Nil)))`
      因为混杂不同类型的数据
    - `Cons(1, 2)`
      因为`2`不是列表
    - `Cons(1, Cons(Nil, Nil))`
      因为混杂不同类型的数据

### 列表的类型

列表的类型的写法为：`List[<类型>]`，列表也是泛型类型，如：

- 整型的列表类型为`List[Int]`
- 字符串的列表类型为`List[String]`
- 浮点数的列表类型为`List[Double]`

### 模式匹配

我们在这里已经看到了如何在月兔中构建列表。为了能够对列表进行运算，我们也需要能够分解列表。因为有两种情况，因此我们需要通过模式匹配来分情况查看列表的内部结构。

```
match <表达式> {
  <模式1> => <表达式>
  <模式2> => <表达式>
}
```

模式可以用数据的构造方式定义。模式中定义了标识符，其作用域为右侧表达式。让我们看一个例子。

```rust
fn head(list: List[Int], default: Int) -> Int {
  match list {
    Nil => default
    Cons(head, tail) => head
  }
}
```

在这个例子中，我们希望访问一个数字列表的第一项。我们使用模式匹配分情况进行讨论，分为空列表和非空列表。我们分别使用了`Nil`和`Cons`这两个列表的构造器来匹配。如果列表为空，则给出我们的默认值。如果列表有一个值，则我们返回这个值。其中，`head`这个标识符匹配了非空列表的值，而`tail`这个标识符匹配了非空列表的子列表，其作用域就是右侧的表达式。

#### 模式匹配结果的化简

模式匹配的化简可以分为几步
- 简化待匹配的表达式
- 从上到下依次进行匹配
- 匹配成功后，根据模式定义替换表达式中的标识符
- 简化表达式

```rust
fn head_opt(list: List[Int]) -> Option[Int] {
  match list {
    Nil => None
    Cons(head, tail) => Some(head)
  }
}

let first_elem: Int = head_opt(Cons(1, Cons(2, Nil)))
```

```rust
head_opt(Cons(1, Cons(2, Nil)))
```
$\mapsto$ （替换函数内的标识符）
```rust
match Cons(1, Cons(2, Nil)) { 
  Nil => None
  Cons(head, tail) => Some(head)
}
```
$\mapsto$ `Some(1)`（匹配并根据模式定义替换表达式中的标识符）

上面一步可以理解为：
```rust
{
  let head = 1
  let tail = Cons(2, Nil)
  Some(head)
}
```

#### 模式匹配Option

同样地，我们也可以用模式匹配查看`Option`的结构来获得值

```rust
fn getOrElse(option_int: Option[Int], default: Int) -> Int {
  match option_int {
    None => default
    Some(value) => value
  }
}
```

模式匹配中，亦可以省略部分情况（如确认存在值），来构造部分函数
```rust
fn get(option_int: Option[Int]) -> Int {
  match option_int { // 编辑器会警告我们有模式尚未被匹配
    Some(value) => value
    // 若option_int为None则会程序出错中止
  }
}
```

## 递归

递归有如下的例子
- **G**NU is **N**ot **U**nix
- **W**ine **I**s **N**ot an **E**mulator
- 斐波那契数列的计算（第一项为1，第二项为1，第n项为第(n-1)项与第(n-2)项之和）
- 山里有个庙，庙里有个老和尚和小和尚，一天，老和尚给小和尚讲故事：
    - “山里有个庙，庙里有个老和尚和小和尚，一天，老和尚给小和尚讲故事：
        - ‘山里有个庙，庙里有个老和尚和小和尚，一天，老和尚给小和尚讲故事…’”

递归是将问题分解为与原问题相似的、规模更小的问题来求解。递归应当有边界条件，否则便会像老和尚和小和尚讲故事一样喋喋不休无穷尽。而对于一个函数而言，递归意味着在函数的定义中，直接或间接地使用函数自身。例如：

```rust
fn fib(n: Int) -> Int {
  if n == 1 || n == 2 { 1 } else { fib (n-1) + fib (n-2) }
}
```

在斐波那契数列中，如果项数大于2，则它的值是前两项值的和。那么如何求前两项的值呢？我们递归使用了`fib`函数本身来计算前两项的值。

```rust
fn even(n: Int) -> Bool {
  n != 1 && (n == 0 || odd(n - 1))
}
fn odd(n: Int) -> Bool {
  n != 0 && (n == 1 || even(n - 1))
}
```

而在自然数的奇偶性判断中，我们判断一个数是否为偶数，取决于它是否为0或1，或者它的邻近值是否为奇数。同样地，一个数是否为奇数，取决于它是否为0或1，或者它的邻近值是否为偶数。它们间接地调用了自身，因此也是递归函数。

### 在列表上的递归

列表的数据结构是递归定义的。让我们回忆一下它的定义：一个空列表或者一个值和一个列表。这里的列表便递归了。因此，在列表上的操作十分适合用递归函数进行定义。例如这里的求列表长度的函数便同时运用了模式匹配和递归。

```rust 
fn length(list: List[Int]) -> Int {
  match list {
    Nil => 0
    Cons(_, tl) => 1 + length(tl)
  }
}
```

若列表为空，则长度为0；若列表非空，则长度为1加上子列表的长度。对情况的判断使用了模式匹配，对递归结构的计算则使用了递归函数。

### 递归的运算

递归的运算与函数的运算相同。只不过，除了替换参数所定义的表达式以外，还需要将内部出现的自身再一次用自身的定义替代。以刚才定义的求列表长度的`length`函数为例：

```rust
length(Cons(1, Cons(2, Nil)))
```
$\mapsto$ 替换为函数定义
```rust
match Cons(1, Cons(2, Nil)) {
  Nil => 0
  Cons(_, tl) => 1 + length(tl) // tl = Cons(2, Nil)
}
```
$\mapsto$ 模式匹配并替换标识符
```rust
1 + length(Cons(2, Nil))
```
$\mapsto$ 再次调用函数
```rust
1 + match Cons(2, Nil) { 
  Nil => 0
  Cons(_, tl) => 1 + length(tl) // tl = Nil
}
```
$\mapsto$ 模式匹配并替换标识符
```rust
1 + 1 + length(Nil)
```
...
$\mapsto$ `1 + 1 + 0` $\mapsto$ `2`

### 结构化递归

像这种定义在递归的数据结构上的递归，我们称之为结构化递归。我们需要定义基础数据结构的计算，对应着终结递归的情形，例如空列表的情况。之后，我们需要定义对于中间数据结构的计算，对应着递归的情形，例如非空列表的情况。通常，我们可以用数学归纳法来证明结构化递归定义的函数是正确的

举个例子，我们需要证明以下命题：命题：对于任意列表`a`，令列表`a`长度为$l_1$，子列表`tail(a)`长度为$l_2$，则总有$l_1 \geq l_2$。

```rust 
fn tail(list: List[Int]) -> List[Int] {
  match list {
    Nil => Nil
    Cons(_, tail) => tail
  }
}
```

此处求子列表的函数非两种情况，若列表为空，则返回空列表；若列表非空，则返回子列表。

- 证明：对`a`分类讨论
  - 首先讨论最根本的情形：若`a`为空（`Nil`），则子列表`tail(a) == a`，两者长度均为0，命题成立
  - 接着，我们讨论归纳的情形：若`a`为非空（`Cons(head, tail)`），则子列表`tail(Cons(head, tail)) == tail`，由length定义可知$l_1 = l_2 + 1 > l_2$，命题成立
  - 由数学归纳法，原命题成立

在拓展阅读中我们还会推荐一些读物供大家参考。

## 动态规划

当我们定义出正确的程序后，我们依然有其他的追求，那就是，我们的程序运行得够快吗？

以斐波那契数列为例。我们在官网为大家提供了两个实现。求第40项的时候，在我的电脑上已经可以观察到性能的差别了：第一种方法需要几秒，而第二种方法几乎瞬间完成。我们分析一下简单的计算方法，看一下它为什么这么慢。如图所示，求解`f(5)`需要计算`f(3)`，而求解`f(4)`的时候，还要再一次求解`f(3)`。因此，每一次求值时，我们都需要计算前两项的值，而同样地，它们也会计算更前面的项的值。这就导致了一个问题，我们观察到了大量重复计算。大家可以大致数一下求`f(3)`需要应用几次函数，而`f(4)`需要应用几次函数，`f(5)`需要应用几次函数。大家可能会发现，每增加一项，函数的应用次数几乎要翻倍。

这个性能显然是不能被接受的。因此，我们可以采用动态规划这一技巧来避免这些问题。

动态规划，即是将问题分解为与原问题相似的、规模更小的问题来求解。这听起来像是递归的定义，但动态规划是对递归的一种优化。动态规划有两个适用条件。一个条件是，有重叠的子问题。动态规划对每一个子问题求解一次，将其保存，避免重复运算。另一个条件是，有最优子结构。因为我们只对子问题计算一次，因此对子问题的最优解应当也是最优解的一部分。

动态规划分为两种：自顶向下和自底向上。
- 自顶向下：针对每个子问题，如果已求解，直接使用缓存结果；否则求解并缓存
- 自底向上：先解决子问题，再从子问题的解构建更大的子问题的解

### 动态规划，以斐波那契数列为例

求解斐波那契数列符合使用动态规划的条件

- 有最优子结构：`fib(n)`的值可以被用来计算`fib(n + 1)`和`fib(n + 2)`的值
- 有重叠子结构：`fib(n + 1)`与`fib(n + 2)`的求解均需要子问题`fib(n)`的值

![](./fib_unique.drawio.png)

可以从图中看到，如果我们重复使用了之前的计算结果，那么我们总的函数应用次数只是我们所需要求的项数，增长速度相比最简单的实现方式变慢了。

我们用两种方式来实现：自顶向下和自底向上。

为了缓存我们之前的计算结果，我们需要一个数据结构。考虑到我们缓存的结果数量会随着问题的规模增长而增长，因此一个理想的数据结构的平均存取速度应当与当前存储数据量大小无关。按照第一节课所说的，我们定义一下这个数据结构所应当有的接口。首先，我们应该能够构造一个数据结构。我们可以预先告知我们所需要存取的数据总量。之后，以斐波那契数列为例，我们需要能够针对每个项数存储一个结果，因此我们需要一个`put`函数向数据结构中存储一个整型以及对应的一个长整型。这个存储操作我们只期待它执行一次。之后，我们也应当有个`get`函数让我们读取存储的结果。但此时对应子问题可能尚未求解完毕，因此我们用`Option`类型来承载这个结果。

事实上，符合条件的数据结构有很多种。我们的样例代码采用`AVLMap[Int, Int64]`为例，因为这是一个相对简单的数据结构。但模块化编程的好处就在于，我们只需要关心接口而无需关心具体实现。事实上，我们完全可以把它替换成其他的数据结构，例如`Array[Option[Int64]]`等。

定义完了数据结构，让我们来看具体实现。自顶向下的解法为，每次计算时看当前数据结构中是否存有我们所求的项数所对应的结果。如果有，我们直接使用。如果没有，我们需要计算求解，并且将结果添加至数据结构中方便下次计算。

```rust
fn fib1(num: Int) -> Int64 {
  fn aux(num: Int, map: AVLMap[Int, Int64]) -> (Int64, AVLMap[Int, Int64]) {
    match get(map, num) {
      Some(result) => (result, map)
      None => {
        let (result_1, map_1) = aux(num - 1, map)
        let (result_2, map_2) = aux(num - 2, map_1)
        (result_1 + result_2, put(map_2, num, result_1 + result_2))
      }
    }
  }
  let map = put(put(make(num), 1, 1L), 2, 1L)
  aux(num, map).0
}
```
如代码所示。我们定义了一个辅助的递归函数帮助计算。我们在第三行根据传入的缓存和项数判断当前是否已经有了结果。如果有，那么结果就是缓存的结果，并且对于缓存我们没有进行修改。如果没有，那么我们便要进行求解。需要注意的是，在求解所需的一个项的同时，我们也需要更新缓存，以确保缓存中存有此次求解的结果。因此，我们的辅助递归函数把缓存结构作为参数，并将其返回。在求解第二项的时候，我们需要把更新后的缓存传进去，并再次获得更新后的缓存。最后，我们在求解成功当前项之后，还是要把当前项也加入缓存，并且作为结果返回。可以注意到，我们这里的`let`定义同样也使用了模式匹配，匹配了我们的元组结构。

这样将缓存不断地传递，在书写时会有些麻烦，因此月兔也提供了可变变量方便大家的书写。

```rust
fn fib1_mut(num: Int) -> Int64 {
  var map = put(put(make(num), 1, 1L), 2, 1L) // 通过var声明可变变量
  fn aux(num: Int) -> Int64 {
    match get(map, num) {
      Some(result) => result
      None => {
        let result_1 = aux(num - 1)
        let result_2 = aux(num - 2)
        // 通过 <变量> = <值> 修改绑定的值
        map = put(map, num, result_1 + result_2) 
        result_1 + result_2
      }
    }
  }
  aux(num)
}
```

可变变量，也就是说绑定的数据并不是不发生变化，而是可以被改变。例如代码样例中，我们将缓存结构通过`var`进行了定义，并赋予了最初的值。之后，我们通过`_ = _`的方式对它进行了修改。在此之后再使用`map`这个值便是获得修改后的值。如此，我们便可以将我们的定义稍稍化简。关于可变变量，我们之后还会再遇到。

接下来让我们看看自底向上的例子

```rust
fn fib2(num: Int) -> Int64 {
  fn aux(n: Int, map: AVLMap[Int, Int64]) -> Int64 {
    let result = getOrElse(get(map, n - 1), 1L) + getOrElse(get(map, n - 2), 1L)
    if n == num { result } else { aux(n + 1, put(map, n, result)) }
  }
  let map = put(put(make(num), 0, 0L), 1, 1L)
  aux(1, map)
}
```

自底向上，意味着先计算子问题，再从子问题的解构建更大的子问题，直到子问题等于原问题。这里，我们从最初的第一项开始，不断向后进行求解。我们首先从前两项构建当前子问题的解。之后，我们判断，当前的子问题是不是就是原问题？如果是，那我们已经获得了解；如果没有，那我们继续进行更大的子问题的计算，在这里也就是计算斐波那契数列的后一项。

当然，我们在这里会发现，我们每次构建更大的子问题的时候，只需要保留前两项便足够，更早的数据其实可以被遗忘。因此，我们可以简化我们的结构，舍弃缓存，直接通过递归参数传递，如

```rust
fn fib2(num : Int) -> Int64 {
  fn aux(n: Int, acc1: Int64, acc2: Int64) -> Int64 {
    match n {
      0 => acc1
      _ => aux(n - 1, acc2, acc1 + acc2)
    }
  }
  aux(num, 0L, 1L)
}
```

![](./fib_aux.drawio.png)

我们可以从图中看到，具体的计算流程。一个斐波那契数列就有那么多种解法。你能想到别的思路吗？

## 总结

我们今天学习了
  - 函数的定义与运算
  - 列表的定义与模式匹配
  - 递归的含义与运算
我们还对时间复杂度有了感性的认识。

我们在此对于设计的一些概念的解释都还不够深入。为此我们推荐大家进行拓展学习。在这里给大家推荐几本好书：
- 想要了解如何用数学归纳法证明结构化递归的正确性，可以参阅：*Software Foundations* 前三章 或 *Programming Language Foundations in Agda* 前三章，其中后者有中文版
- 想要更深入了解算法的定义以及时间复杂度的定义等，可以参阅：《算法 第四版》第一章或《算法导论》第三章

参考代码：<https://try.moonbitlang.cn/#e4fa5493>

斐波那契自顶向下：<https://try.moonbitlang.com/#6dfd2852> <https://try.moonbitlang.com/#65113dcb>

斐波那契自底向上：<https://try.moonbitlang.com/#62319080> <https://try.moonbitlang.com/#b3948997>

AVL树实现：<https://try.moonbitlang.com/#aa3e7eb4>