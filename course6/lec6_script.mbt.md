# 现代编程思想：泛型与高阶函数

大家好，欢迎来到由IDEA研究院基础软件中心为大家带来的现代编程思想公开课。今天让我们来学习泛型和高阶函数。

我们在开发的时候会遇到相似的数据结构，相似的运算。在这种时候，我们可以通过建立良好的抽象来对这些信息进行重复利用，既可以保证可维护性，也可以让我们忽略一些细节。良好的抽象应当具备两个条件：首先是代码中重复多次出现相同的模式或结构，并且抽出的逻辑是具有合适的语义的时候。例如，对于一个整数的列表进行求和就是一个很好的例子。我们在很多场合都可能会需要对整数列表进行求和运算，因此会有多次重复。而求和这一操作具有着合适的语义，因此适合被进行抽象。我们可以把这个运算抽象到一个函数。
编程语言在这个过程中则为我们提供了各种抽象的手段，例如函数、泛型、高阶函数以及接口等。我们这个章节将会介绍泛型与高阶函数，下个章节将会介绍接口。

# 泛型函数与泛型数据

我们首先以堆栈这个数据结构为例，来看一下我们为什么会用到泛型，怎么用泛型。

堆栈是一个由一系列对象组成的一个集合，这些对象的插入和删除遵循后进先出原则，也就是Last In First Out，一般缩写为LIFO。例如左下图中的船上码放的集装箱，显然我们从上面把新的集装箱堆叠上去，而当我们取走集装箱的时候，我们也是从上面取走，也就是最后放入的集装箱最先被取走。右侧的石堆一样，如果不想打翻这个石堆，那么我们只能从上面添加石头，或者将最近添加的石头移走。这样的结构就是堆栈。我们的生活中还有很多很多的例子，在此就不一一枚举。

对于数据类型的堆栈，我们可以定义如下的操作。以存储整数的堆栈`IntStack`为例，我们可以创建一个新的空的堆栈；我们可以往堆栈中添加一个整数；我们可以尝试试图从堆栈中取走一个元素，因为堆栈可能为空，因此这个元素可能有也可能无，用Option包裹。
如下图所示，我们添加一个2，之后取走一个2。我们简单的实现这个堆栈的定义。
在代码示例中，我们看到我们将第一个参数设置为`IntStack`，并且变量名称为`self`，这允许我们链式地调用函数。也就是我们可以写`empty.push.pop`，而不是`pop(push(empty))`。这种写法的更深层的含义，我们下节课介绍。
回到我们的代码，我们根据堆栈的操作定义了一个递归的数据结构：一个堆栈可能为空，也可能为一个元素和一个堆栈。创建堆栈即是创建一个空堆栈，而添加元素，则是构建一个非空的堆栈，其中栈顶元素是我们要添加的元素，而底下的堆栈则是原来的堆栈。取出堆栈，则需要通过模式匹配，若模式为空，则没有数值可取；若模式非空，则可以取一个元素。
我们可以看到堆栈的定义和列表的定义十分类似。事实上，在月兔中，内建库自带的列表就是一个堆栈。

在定义了整数的堆栈后，我们也会想定义其他类型的堆栈，例如字符串的堆栈。这很简单，我们在此仅仅展示代码，不作解释。事实上，仔细观察便会发现，字符串的堆栈和整数的堆栈长得一模一样，除了一些类型的定义不同。而如果我们想要添加更多的数据类型，那难道我们要对每一个数据类型都重新定义一个堆栈的数据结构吗？这显然是不能接受的。

因此月兔提供了泛型这一语言特性。泛型也就是将类型作为参数，让我们能定义更加抽象、更加可服用的数据结构与函数。例如我们这里的堆栈，我们可以在名称后面加上一个类型参数`T`来表示它实际存储的数据类型。之后定义的函数也是同样，在函数名称后我们会看到一个`T`作为类型参数，代表稍后操作的堆栈中存储的数据类型以及我们想要添加的数据的类型。我们只需要像计算函数时将标识符替换为参数一样，将`T`替换为具体的类型，便可以得到实际的数据结构和函数。例如，这里的`T`如果替换为`Int`，那我们获得的就是先前定义的`IntStack`。

语法我们刚才介绍过了，这里可以看看更多的例子。例如，我们可以定义一对数据，也就是二元组。二元组的两个元素不必是相同类型，因此我们的类型参数也有两个。在`Pair`中存储的值`first`和`second`也分别是这两个类型。之后我们定义一个函数，它可以对任意类型进行运算，总是返回输入值。`Stack`和`Pair`本身可以被看成是类型上的函数，它们的参数是`T`，运算的结果则是`Stack[T]`和`Pair[A, B]`这些具体的类型，因此它们可以被看成是类型构造器。类型参数在多数时候都可以被月兔根据具体的参数类型推导。例如这里的截图中，`empty`的类型最初是未知的。但是在`push(1)`之后，我们明白，它是被用来装整数的，因此，我们可以推出`push`以及`empty`的类型参数应当是整型`Int`。

现在让我们来看一个另一个泛型数据结构：队列。我们上节课已经在广度优先排序的时候用到了队列。回忆一下，队列是一个先进先出的数据结构，就像我们日常排队一样。我们在这里定义如下的操作，其中队列叫做`Queue`，它有一个类型参数。因此，所有的操作也都有一个类型参数，来表明它所拥有的数据的类型。我们定义了三个和堆栈类似的操作，唯一的区别是，在取出元素的时候，应当取出最先加入队列的元素。
队列的实现可以通过一个列表，或者说堆栈模拟，我们添加的时候将元素加在列表最后，也就是堆栈底部，取的时候从列表最前取，也就是堆栈顶部。取的操作十分快捷，因为只需要进行一次模式匹配即可。但是添加元素的操作却需要重新构建整个列表。像我们现在所看到的，2开头的本来是一个空列表，现在却要被替换为一个包含2、3的列表；同样地，1开头的本来是只包含2的列表，现在却要被替换为包含2、3的列表。也就是说，整个列表从头到尾都要被重新构建一番，耗时与整个列表长度成正比。效率十分低下。
我们使用两个堆栈来模拟队列。其中一个堆栈负责取出操作，一个堆栈负责存储操作。可以看到，在定义中的两个类型都是`Stack[T]`，而`T`则来自整个队列的类型参数。我们在添加数据的时候，直接存入`back`：这一步通过在原来的数据结构上构建一个新的数据结构，因此速度很快；而取出操作也只需要进行一次模式匹配，同样不慢。而当`front`中元素被取完，此时我们需要把`back`中所有的元素通过一次旋转放入`front`中。我们在每次操作后进行这个检查，保证只要队列非空，则`front`非空，这是我们队列操作的不变式，也就是必须成立的条件。这一次的旋转的开销非常大，与当时的列表长度成正比，但是好消息是，这一次开销可以被平摊出去，因为一次旋转之后，接下来的多次取出操作都不再需要进行旋转。
我们来看一下具体的例子。在下方，我们一开始拥有一个空的队列，因此两个堆栈均为空。在进行了一次添加操作之后，我们把一个数字添加到`back`中去。此时我们对队列进行整理，发现队列不为空，但`front`为空，这不符合我们之前所说的不变式，因此我们对`back`中的堆栈进行一次反转操作之后放到`front`中去。之后，我们再次进行操作，则继续向`back`中添加元素。因为此时`front`不为空，因此符合不变式，我们也不会额外进行处理。
之后，我们反复进行添加，都只是在`back`中进行快速的添加创建新元素这一操作。然后，我们从`front`中取出元素。我们一样在操作后检查不变式是否被打破。我们发现，队列非空，而`front`为空，因此我们对`back`中的堆栈再次进行反转之后放到`front`中去。之后，我们便可以正常地从`front`中取元素了。可以看到，一次反转之后便可支持多次操作，因此总体开销相比每一次都重新构建列表而言是小很多的。
现在大家看到的就是队列的代码。可以看到，我们大量应用了泛型，因此我们的队列可以放任何的类型，包括装有其他元素的队列。我们这里看到的函数都是对我们刚才解释的算法的具体实现。第七行可以看到，我们通过`back.push`的方式调用了堆栈的`push`函数。我们将会在第七课具体解释。

# 高阶函数

这个部分依然是围绕着如何利用月兔提供给我们的功能来减少重复代码、提高代码的复用，因此让我们从一个例子开始看起。

我们会有一些列表操作。例如，我们要求一个整数列表的和，我们利用结构化递归写出如下代码：若为空，则和为0；若非空，则和为当前值加剩余列表的元素求和。
又比如说，我们要求一个任意数据类型的列表的长度。同样利用结构化递归，我们可以写出如下代码：若为空，则长度为0；若非空，则长度为1加上剩下的列表的长度。
我们仔细观察会发现这两个结构具有着相当的相似性：都是结构化递归，在为空的时候有一个默认值，而非空的时候则都是对当前值进行一个处理后与剩余列表的递归结果进行一个运算。例如，在求和的例子中，默认值是0，而二元运算则是相加。在求长度的例子中，默认值也是0，而二元运算则是将当前值替换为1，然后与剩下的结果相加。那么如何重用这个结构呢？我们可以写成一个函数，将这个默认值以及这个二元运算作为参数传进来。

这就不得不提到，在月兔中，函数是一等公民。这就意味着，我们既可以把函数作为参数传递，我们也可以将函数作为极速三结果存储。例如刚才的结构，我们就可以定义为如下的函数，其中我们将`f`这个函数作为参数传进来，并且在第四行使用这个函数进行计算。
我们这里可以看另一个例子。如果我们想要重复一个函数的运算，那么我们可以定义如第一行所示的`repeat`。`repeat`接受一个函数作为参数，之后返回一个函数作为结果。它的运算结果就是会将原函数计算两次的函数。例如，如果我们有一个加一的函数，和一个加二的函数。我们如果使用`repeat`并将加一的函数作为参数传入，那么作为结果，我们会获得一个加一两次，也就是加二的函数。我们用`let`来绑定这一函数到`add_two`上，之后用正常的函数计算的语法进行运算，获得结果。
我们来看一下这里的化简。首先是`add_two`，绑定的是`repeat(plus_one)`。在化简的时候，我们像正常的函数一样，用参数去替换表达式中的标识符，于是获得了一个函数作为结果。到这一步，我们无法继续化简。接着我们来看应用`add_two`进行计算的时候。那么同样地，我们替换表达式中的标识符，对`plus_one`进行化简。之后，我们再次化简一次，并最终获得了我们的结果，`4`

函数的类型我们之前提过，是从接受的参数到输出参数，其中接受的参数是用括号包裹的。例如，整数到整数，那就是`(Int) -> Int`。而第二行则是整数到函数的例子。注意到，这里的函数的参数也要用括号包裹来表示。这个函数的类型实际上等同于是将后面的整个函数类型用括号包裹，如第三行。如果是从函数到整数，那么我们刚才提过，接受的参数是要用括号包裹的，因此它应该看起来像第四行那样，而不是像第二行。

我们在这里再来看几个常见的高阶函数的应用。高阶函数，也就是接受函数的函数。我们刚才看到的`fold_right`就是其中的一个常见的例子。我们在下方画出它的表达式树。可以看到，对于一个从1到3的列表，我们每次都是将`f`应用到当前元素以及剩下的元素的运算结果上，因此看上去，我们是在用`b`从右往左一个个构建折叠起来最终获得一个结果，因此它被称为`fold_right`。那么如果我们换个方向，将列表从左侧向右侧折叠，那么我们获得的便应该是`fold_left`。这里，我们只需要调换顺序，先将当前元素与之前积累的结果进行一个处理，然后再将处理的结果放入后续的处理当中，如大家第四行所见。这样的话便是从左向右折叠。

另一个常见的高阶函数的应用是将函数中的元素进行一一映射。例如，如果我们有一些人的信息，而我们只需要他们的名字，那么我们就可以通过`map`这个映射函数，接受`f`这个参数，来对列表中的元素进行一一映射，最后获得一个新的列表，而这个列表中的元素类型则变成了`B`。这个函数的实现十分简单，同样只需要结构化递归即可。最后的应用则是如第8行所示。不知道大家有没有一种感觉，这个`map`的结构好像在哪里看到过：结构化递归，空值有一个对应的默认值，非空时对当前值进行处理后和递归结果进行二元运算。事实上，完全可以通过`fold_right`来实现`map`，其中默认值是空列表，而二元运算则是`Cons`这个构造器。我们在这里给大家留一个思考题，如何用`fold_right`来实现`fold_left`呢？一个小提示是，可能会有一个概念叫做`Continuation`，它代表着计算出当前值之后剩余的运算，一般是一个函数，参数是当前值，返回值则是整个程序的运算结果。

在学习了泛型和高阶函数之后，我们便可以将上节课学习的二叉搜索树定义为更一般的二叉搜索树，可以存储各种数据类型，而不仅仅是接受整数。其中，数据结构本身接受一个类型参数，来代表它所存储的数据类型。而考虑到二叉搜索树应当是有序的，那么我们需要知道如何排列这个特定的类型，因此我们接受一个比较函数作为参数，它应当返回一个整数，以负数、0和整数来分别代表比较的结果，是小于、等于还是大于，如代码所示。事实上，我们完全可以利用月兔的另一个语言特性来省略这一个参数。我们将会在下节课进行介绍。

总结，我们在本章节介绍了泛型以及函数是一等公民这两个概念，看到了月兔中是如何实现的。我们也介绍了数据结构堆栈和队列的实现。我们推荐大家阅读Software Foundations第四章或者Programming Language Foundations in Agda第十章。
